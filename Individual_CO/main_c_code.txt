/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under Ultimate Liberty license
  * SLA0044, the "License"; You may not use this file except in compliance with
  * the License. You may obtain a copy of the License at:
  *                             www.st.com/SLA0044
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dac.h"
#include "fatfs.h"
#include "tim.h"
#include "usb_host.h"
#include "gpio.h"

#include "ff.h"
#include "ffconf.h"
#include "sys/stat.h"
//#include "mp3dec.h"

//#define _USE_FIND  1
#define _FS_MINIMIZE 0

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */
DAC_HandleTypeDef hdac;

TIM_HandleTypeDef htim6;

TIM_HandleTypeDef htim2;

uint32_t values2[] = {600, 600, 600, 500, 0, 0, 0, 0,400, 500, 500, 0,0,0,0,600, 600, 500,0,0,0,0,0,600, 500, 550};
uint32_t values1[] = {327, 0,0,45,45,56, 340,200,100,50,1,20,300,0};

long k = 0;
long m = 0;
long text_length = 0;
long audio_length = 0;
long where_length = 0;
/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ApplicationTypeDef Appli_state;

//FATFS variables
FATFS myUsbFatFS;
//USB Logical Path
char USBHPath[4];   /* USBH logical drive path */

//File IO Variables
FIL myFile;
DIR myDirectory;
UINT i;
UINT n;
UINT t;
FILINFO myFileinfo;
FRESULT res;
UINT byteswritten, bytesread;

//char rwtext[1000]; //An empty array that main.c reads a file into or writes text on to send to the flash drive
char buffer[100]; //Array that is used to for general purpose recording.
char small_buffer[10];

char directoryname[50]; //Array that contains desired folder name to read files from
char audio_directory[50]; //Array that contains the path of folder that contains audio files
char audio_directory_path[50]; //path of audio folder
char text_directory[50]; //Array that contains the path of folder that contains chapter folders
char text_directory_path[50]; //path of directory folder

char chapter_directory[50]; //Array that contains path of chapter folder
char page_directory[50]; //Array that contains path of page folder

char text_path[100]; //Array that contains the file path of the current text data to read from
char audio_path[100]; //Array that contains the file path of the current audio data to read from
char where_path[100]; //Array that contains the file path of the current where am I audio data to read from
char filtered[30];




volatile int chapter_num = 1; //the current chapter number user is on
volatile int page_num = 1; //the current page number user is on
volatile int text_num = 0; //the current text data user is on

int N = 0; //The number of objects inside a directory
int M = 0; //N - 1
int CN = 0; //The number of chapters inside a directory
int CM = 0; //CN - 1


char text_read[1000];//output text array
char braille_uncontracted[50]; //uncontracted braille translation output
char braille_contracted[50]; //uncontracted braille translation output
char braille_output[50]; //the resultant output translation braille


//Regular Variables
int directoryname_selected = 0;
int num = 0;
volatile int op_mode = 0; //Current operation mode: 0 - Folder Selection Mode, 1 - Play Files Mode
//During Folder Selection Mode, program does the following:
//1.) Obtain user-entered desired directory path within root directory of USB drive
//2.) Obtain Audio and Text Folder Paths


//variables used for enabling/disabling scrolling speed
volatile int present_1 = 0; //the present logic state of button press 1
volatile int present_2 = 0; //the present logic state of button press 2
volatile int before_1 = 0; //the previous logic state of button press
volatile int before_2 = 0; //the previous logic state of button press
volatile int i_1 = 0; //state indicator
volatile int i_2 = 0; //state indicator
volatile int j_1 = 0; //state indicator
volatile int j_2 = 0; //state indicator
volatile uint32_t lastDebounceTime = 0;  // the last time the output pin was toggled to 1
volatile uint32_t debounceDelay = 30;    // the debounce time required to wait for
volatile uint32_t Delay;             // the delay that makes the device wait


int start_text_scrolling = 0; //start scrolling the text of text_array to be displayed



int play_files_mode = 0; //make play button into scroll enabler mode
int trigger_DAC = 0;
volatile int where_trigger = 0;

//variable used for enabling chapter navigation mode
int nav_chapter_mode = 0;

volatile bool flag1 = false;
volatile bool flag2 = false;



//MP3 Variables
#define FILE_READ_BUFFER_SIZE 8192
//MP3FrameInfo            mp3FrameInfo;
//HMP3Decoder             hMP3Decoder;
FIL                     file;
char                    file_read_buffer[FILE_READ_BUFFER_SIZE];
volatile int            bytes_left;
char                    *read_ptr;
// mp3 functions
//static void AudioCallback(void *context, int buffer);
//static uint32_t Mp3ReadId3V2Tag(FIL* pInFile, char* pszArtist,
//        uint32_t unArtistSize, char* pszTitle, uint32_t unTitleSize);
//static void play_mp3(char* filename);
//static FRESULT play_directory (const char* path, unsigned char seek);




//audio_read buffer
char text_audio[FILE_READ_BUFFER_SIZE];
int text_audio_int[500];
//decoded PCM data of audio_read buffer
static int16_t text_audio_decoded[4096];
//where_audio buffer
char where_audio[FILE_READ_BUFFER_SIZE];
int where_audio_int[500];
//decoded PCM data of where_audio buffer
static int16_t where_audio_decoded[4096];

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void MX_USB_HOST_Process(void);

/* USER CODE BEGIN PFP */
//1. read text function
bool read_text(void);
//2. read audio function (char)
bool read_audio(void);
//3. Decode text audio (PCM)
void decode_read_audio(void);
//4. read where audio function (char)
bool read_where(void);
//5. decode where audio function (PCM)
void decode_read_where(void);
//3. Desired Directory Name Read function
FRESULT get_directory_name(char* path);
//4. Count the Number of objects in directory
void count_objects(char* path);
//5. Get the text and audio subdirectories
void get_subdirectories(char* path);
//6. Count the number of chapters inside text folder
void count_chapters(char* path);
//7. Create a Chapter Directory
void form_chapter_directory(void);
//8. Create a Page Directory
void form_page_directory(void);
//9. Create a text file path
void form_text_path(void);
//10. Determine the file path of text file to read
void get_text_filepath(void);
//11. Get Next Audio Filepath function
void get_audio_filepath(void);
//12. Get Next Where Filepath function
void get_where_filepath(void);
//13. braille translation function
void braille_translation(char* path);
//14. Display both braille output and audio file
void display_data(void);
//15. Increment Chapter Function
void increment_chapter(void);
//16. Decrement Chapter Function
void decrement_chapter(void);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */

int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DAC_Init();
  MX_FATFS_Init();
  MX_USB_HOST_Init();
  MX_TIM2_Init();
  MX_TIM6_Init();
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET); //turn on vbus enabling pin

    //Folder Selection Mode
    while (op_mode == 0)
    {
      /* USER CODE END WHILE */
      MX_USB_HOST_Process();

      switch(Appli_state)
      {
          case APPLICATION_IDLE:
          break;

          case APPLICATION_START:
              if(f_mount(&myUsbFatFS, (TCHAR const*)USBHPath, 0) == FR_OK)
              {
                  //turn green led on
                  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);
              }
          break;

          case APPLICATION_READY:
              count_objects(directoryname); //count the number of items in root directory of flash drive
              get_directory_name(directoryname); //Prompt the user to select the folder from which files should be read
              get_subdirectories(directoryname); //Obtain the directories of the text and audio directory folders within selected folder
              count_chapters(text_directory_path); //Count the number of chapters in the text folder of selected folder

              HAL_TIM_Base_Start_IT(&htim2); //Activate scrolling speed toggling
              HAL_GPIO_WritePin(PLAY_OUT_GPIO_Port, PLAY_OUT_Pin, GPIO_PIN_SET); //Make Play button output initialize to a 1 for enabling scrolling by default
              play_files_mode = 1; //enable play button scrolling enable/disable functionality
              nav_chapter_mode = 1; //enable chapter navigation functionality
              op_mode++; //Transition to Play Files Mode in infinite loop
              break;

          case APPLICATION_DISCONNECT:
              //turn green led off
              HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
              break;
      }
    }
    while (1) //Play Files Mode
    {
        t = 0;
        //flag1 = true;
        if(flag1 == false && flag2 == false)
        {
            get_text_filepath(); //Determines the file path of the next text data to read from
        }
        else if(flag1 == true)
        {
            increment_chapter(); //If forward button has been pressed, go to first page and text of next chapter.

            flag1 = false; //Forward button flag has been completed, so clear it
        }
        else if(flag2 == true)
        {
            decrement_chapter(); //If back button has been pressed, go to first page and text of previous chapter.
            flag2 = false; //Back button flag has been completed, so clear it
        }


        get_audio_filepath(); //Determines the file path of the next audio data to read from
        get_where_filepath(); //Determines the file path of the where audio data to read from

        read_text(); //read the contents of text data currently selected into text_read buffer
        read_audio(); //read the raw contents of corresponding audio data into audio_read buffer
        read_where(); //read the raw contents of corresponding where an I audio data into where_audio buffer

        braille_translation(text_read); //translate the contents of text_buffer into braille
        display_data(); //Display contents of translated braille on braille display, gives DAC the cue for when to start playing audio
    }

        /* USER CODE END 3 */
  }

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

  /** Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 168;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  RCC_OscInitStruct.PLL.PLLR = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48;
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48CLKSOURCE_PLLQ;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

//USB Test Read Function
bool read_text(void)
{
    if(f_open(&myFile, (TCHAR const*)text_path, FA_READ) != FR_OK)
    {
        /*HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
        return 0; //error!*/
    }

    text_length = f_size(&myFile);
    memset(text_read,0,sizeof(text_read));

    for(i=0; i<text_length; i++)
    {
        res = f_read(&myFile, (char*)&text_read[i], 1, &bytesread);
        if(text_read[i] == 0x00) //NULL string
        {
            bytesread = i;
            break;
        }
    }

    f_close(&myFile);//close file
    return 1; //success
}

bool read_audio(void)
{
    if(f_open(&myFile, (TCHAR const*)audio_path, FA_READ) != FR_OK)
    {
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
        return 0; //error!
    }

    //audio_length = f_size(&myFile);
    //char* audio_read; //Create variable length array pointer
    //audio_read = (uint32_t*)malloc(audio_length * sizeof(uint32_t));

    /*audio_length = sizeof(text_audio);
    memset(text_audio,0,audio_length);

    for(i=0; i<audio_length; i++)
    {
        res = f_read(&myFile, (char*)&text_audio[i], 1, &bytesread);
        if(text_audio[i] == 0x00) //NULL string
        {
            bytesread = i;
            break;
        }
    }
    bytesread = 0;
    f_close(&myFile);//close file
    return 1; //success*/


    audio_length = sizeof(text_audio_int);
        memset(text_audio_int,0,audio_length);

        for(i=0; i<audio_length; i++)
        {
            res = f_read(&myFile, (char*)&text_audio_int[i], 1, &bytesread);
            if(text_audio_int[i] == 0x00) //NULL string
            {
                bytesread = i;
                break;
            }
        }
        bytesread = 0;
        f_close(&myFile);//close file
        return 1; //success

}

void decode_read_audio(void)
{
}


bool read_where(void)
{
    if(f_open(&myFile, (TCHAR const*)where_path, FA_READ) != FR_OK)
    {
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
        HAL_Delay(500);
        HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
        return 0; //error!
    }

    //where_length = f_size(&myFile);
    //char* where_audio; //Create variable length array pointer
    //where_audio = (uint32_t*)malloc(where_length * sizeof(uint32_t));

    where_length = sizeof(where_audio);
    memset(where_audio,0,where_length); //clear variable length array

    for(i=0; i<where_length; i++)
    {
        res = f_read(&myFile, (uint32_t*)&where_audio[i], 1, &bytesread);
        if(where_audio[i] == 0x00) //NULL string
        {
            bytesread = i;
            break;
        }
    }
    bytesread = 0;
    f_close(&myFile);//close file
    return 1; //success

    /*where_length = sizeof(where_audio_int);
        memset(where_audio_int,0,where_length); //clear variable length array

        for(i=0; i<where_length; i++)
        {
            res = f_read(&myFile, (uint32_t*)&where_audio_int[i], 1, &bytesread);
            if(where_audio_int[i] == 0x00) //NULL string
            {
                bytesread = i;
                break;
            }
        }
        bytesread = 0;
        f_close(&myFile);//close file
        return 1; //success*/
}


void decode_read_where(void)
{

}


//2. Count number of objects in directory

void count_objects(char* path)
{
    f_opendir(&myDirectory, path); //open root directory of USB drive
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //read file name of the first file in the flashdrive root directory
    memset(path,0,strlen(path)); //Clear previous name from buffer
    strcpy(path, myFileinfo.fname); //copy name into buffer
    N = 0;
    M = 0;
    N++; //Increment number of objects in directory

    while(strcmp(myFileinfo.fname, '\0')) //Count number of objects in directory
    {
        memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
        f_readdir(&myDirectory, &myFileinfo); //Read name into myFileinfo.fname

        if(strcmp(myFileinfo.fname, '\0'))
        {
            N++;
        }
    }
    M = N - 1;
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
    memset(path,0,strlen(path)); //Clear previous name from buffer
    f_closedir(&myDirectory); //close directory
}


//Get name of user-entered desired directory to read files from
FRESULT get_directory_name(char* path)
{
    f_opendir(&myDirectory, path); //open directory
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //read file name of the first file in the directory
    memset(path,0,strlen(path)); //clear buffer
    strcpy(path, myFileinfo.fname); //Copy first object name into buffer

    while(directoryname_selected == 0) //While directory name has not yet been selected
    {
        if(HAL_GPIO_ReadPin(BACK_IN_GPIO_Port, BACK_IN_Pin) == GPIO_PIN_SET) //When back button is pressed...
        {
            HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);
            HAL_Delay(250);
            HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);
            for(i=0; i<M; i++) //Read previous file name by calling f_readdir N-1 times
            {
                memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear the previous reading of myFileinfo.fname
                f_readdir(&myDirectory, &myFileinfo); //file name is read
                memset(path,0,strlen(path)); //Clear the previous reading of file name from buffer
                strcpy(path, myFileinfo.fname); //Copy the currently read file name into buffer
                if(!strcmp(path, '\0')) //If the same filename has been read into path buffer, then close and re-open directory
                {
                    HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
                    HAL_Delay(250);
                    HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);

                    f_closedir(&myDirectory); //close directory
                    f_opendir(&myDirectory, path); //re-open directory
                    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
                    f_readdir(&myDirectory, &myFileinfo); //Read file name into myFileinfo.fname
                    memset(path,0,strlen(path)); //Clear previous file name from buffer
                    strcpy(path, myFileinfo.fname); //copy file name into buffer
                }
            }

        }
        if(HAL_GPIO_ReadPin(FORWARD_IN_GPIO_Port, FORWARD_IN_Pin) == GPIO_PIN_SET) //When forward button is pressed...
        {
            HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);
            HAL_Delay(250);
            HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);

            memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear the previous reading of myFileinfo.fname
            f_readdir(&myDirectory, &myFileinfo); //next file name is read
            memset(path,0,strlen(path)); //Clear the previous reading of file name from buffer
            strcpy(path, myFileinfo.fname); //Copy the currently read file name into buffer
            if(!strcmp(path, '\0')) //If end of directory has been reached, then close and re-open directory
            {
                HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
                HAL_Delay(250);
                HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);

                f_closedir(&myDirectory); //close directory
                f_opendir(&myDirectory, path); //re-open directory
                memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
                f_readdir(&myDirectory, &myFileinfo); //Read file name into myFileinfo.fname
                memset(path,0,strlen(path)); //Clear previous file name from buffer
                strcpy(path, myFileinfo.fname); //copy file name into buffer
            }
        }
        if(HAL_GPIO_ReadPin(PLAY_IN_GPIO_Port, PLAY_IN_Pin) == GPIO_PIN_SET)
        {
            HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
            HAL_Delay(250);
            HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
            directoryname_selected++;
        }
    }
}

//get the file names of the subdirectories of the audio and text folders
void get_subdirectories(char* path)
{
    f_opendir(&myDirectory, path);
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //Read file name into myFileinfo.fname
    memset(audio_directory,0,strlen(audio_directory)); //Clear array
    strcpy(audio_directory, myFileinfo.fname); //create audio directory name

    memset(audio_directory_path, 0, strlen(audio_directory_path));
    strcpy(audio_directory_path, path);
    strcat(audio_directory_path, "/"); //Save directory file path into buffer
    strcat(audio_directory_path, audio_directory); //form full path of audio folder


    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //Read file name into myFileinfo.fname
    memset(text_directory,0,strlen(text_directory)); //Clear array
    strcpy(text_directory, myFileinfo.fname); //create text directory name

    memset(text_directory_path, 0, strlen(text_directory_path));
    strcpy(text_directory_path, path);
    strcat(text_directory_path, "/");
    strcat(text_directory_path, text_directory); //form full path of text folder
}

void count_chapters(char* path)
{
//    HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);
//    HAL_Delay(500);
//    HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);

    f_opendir(&myDirectory, path); //open text directory
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //read file name of the first file in directory
    CN = 0;
    CM = 0;
    CN++; //Increment number of objects in directory

    while(strcmp(myFileinfo.fname, '\0')) //Count number of objects in directory
    {
        memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
        f_readdir(&myDirectory, &myFileinfo); //Read name into myFileinfo.fname

        if(strcmp(myFileinfo.fname, '\0'))
        {
            CN++;
        }
    }
    CM = CN - 1;
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //Clear myFileinfo.fname
    f_closedir(&myDirectory); //close directory
}



void form_chapter_directory(void)
{
    strcpy(chapter_directory, text_directory_path);
    strcat(chapter_directory, "/");
    strcat(chapter_directory, "Chapter");
    memset(small_buffer,0,sizeof(small_buffer));
    itoa(chapter_num, small_buffer, 10);
    strcat(chapter_directory, small_buffer); //form full path of page folder
    memset(small_buffer,0,sizeof(small_buffer));
}

void form_page_directory(void)
{
    strcpy(page_directory, chapter_directory);
    strcat(page_directory, "/");
    strcat(page_directory, "Pg");
    memset(small_buffer,0,sizeof(small_buffer));
    itoa(page_num, small_buffer, 10);
    strcat(page_directory, small_buffer); //form full path of page folder
    memset(small_buffer,0,sizeof(small_buffer));

}

void form_text_path(void)
{
    strcpy(text_path, page_directory);
    strcat(text_path, "/");
    strcat(text_path, "TEXT");
    memset(small_buffer,0,sizeof(small_buffer));
    itoa(text_num, small_buffer, 10);
    strcat(text_path, small_buffer); //form full path of page folder
    strcat(text_path, ".TXT");
    memset(small_buffer,0,sizeof(small_buffer));
}





//Determine the filepath of the next text data to read
void get_text_filepath(void)
{
    text_num++;
    form_chapter_directory(); //generate current chapter directory
    form_page_directory(); //generate current page directory
    form_text_path(); //generate next text path

    if(f_stat(text_path, &myFileinfo) != FR_OK) //if the text path does not exist, check if text# is in next page
    {
        page_num++;
        form_page_directory();
        form_text_path();

        if(f_stat(text_path, &myFileinfo) != FR_OK) //if the text path still doesn't exist, check if text# and page# are in next chapter
        {
            chapter_num++;
            form_chapter_directory();
            form_page_directory();
            form_text_path();
            if(f_stat(text_path, &myFileinfo)  != FR_OK) //if text path still doesn't exist, go back to the first text file.
            {
                text_num = 1;
                page_num = 1;
                chapter_num = 1;
                form_chapter_directory();
                form_page_directory();
                form_text_path();
            }
        }
    }
}


void increment_chapter(void)
{
    chapter_num++;
    if (chapter_num > CN)
    {
        chapter_num = 1;
    }
    form_chapter_directory(); //update chapter directory

    //update page_num so that it is the first page of the next chapter
    f_opendir(&myDirectory, chapter_directory); //open chapter directory
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //read file name of the first file in directory

    int d = 2;
    int e = 0;
    memset(filtered,0,sizeof(filtered)); //Clear buffer
    filtered[e] = myFileinfo.fname[d];
    /*while(strcmp(myFileinfo.fname[d], '\0')) //extract page number from page directory name into an array
    {
        filtered[e] = myFileinfo.fname[d];
        HAL_Delay(5);
        d++;
        e++;
    }*/

    page_num = atoi(filtered);//convert string data in filtered array into int data for page_num*/
    form_page_directory();//form new page directory
    f_closedir(&myDirectory);

    //update text_num so that it is the first text of next chapter
    f_opendir(&myDirectory, page_directory);
    //memset(myFileinfo.fname,0,sizeof(myFileinfo.fname));
    f_readdir(&myDirectory, &myFileinfo);
    d = 4;
    e = 0;
    memset(filtered,0,sizeof(filtered));
    filtered[e] = myFileinfo.fname[d];
    /*while(!strcmp(myFileinfo.fname[d], '.')) //extract page number from page directory name into an array
    {
        filtered[e] = myFileinfo.fname[d];
        HAL_Delay(5);
        d++;
        e++;
    }*/
    text_num = atoi(filtered);
    form_text_path(); //form new text path
    f_closedir(&myDirectory);
    flag1 = false;

}

void decrement_chapter(void)
{
    chapter_num--;
    if (chapter_num == 0)
    {
        chapter_num = CN;
    }
    form_chapter_directory(); //update chapter directory

    //update page_num so that it is the first page of previous chapter
    f_opendir(&myDirectory, chapter_directory); //open new chapter directory
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //read name of the first page in directory

    int d = 2;
    int e = 0;

    memset(filtered,0,sizeof(filtered)); //Clear buffer
    filtered[e] = myFileinfo.fname[d];
    /*while(strcmp(myFileinfo.fname[d], '\0')) //extract page number from page directory name into an array
    {
        filtered[e] = myFileinfo.fname[d];
        d++;
        e++;
    }*/

    page_num = atoi(filtered);//convert string data in filtered array into int data for page_num
    form_page_directory();//form new page directory
    f_closedir(&myDirectory);

    //update text_num so that it is the first text of previous chapter
    f_opendir(&myDirectory, page_directory);
    //memset(myFileinfo.fname,0,sizeof(myFileinfo.fname));
    f_readdir(&myDirectory, &myFileinfo);

    d = 4;
    e = 0;
    memset(filtered,0,sizeof(filtered));
    filtered[e] = myFileinfo.fname[d];
    /*while(!strcmp(myFileinfo.fname[d], '.')) //extract page number from page directory name into an array
    {
        filtered[e] = myFileinfo.fname[d];
        d++;
        e++;
    }*/
    text_num = atoi(filtered);
    form_text_path(); //form new text path
    f_closedir(&myDirectory);
    flag2 = false;

}


void get_audio_filepath(void)
{
    strcpy(audio_path, audio_directory_path);
    strcat(audio_path, "/");
    strcat(audio_path, "SOUND");
    memset(small_buffer,0,sizeof(small_buffer));
    itoa(text_num, small_buffer, 10);
    strcat(audio_path, small_buffer);
    //strcat(audio_path, ".TXT");
    strcat(audio_path, ".MP3");

    /*f_opendir(&myDirectory, audio_directory_path); //open text directory
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //read file name of the first file in directory
    f_closedir(&myDirectory);*/

    memset(small_buffer,0,sizeof(small_buffer));


}

void get_where_filepath(void)
{
    strcpy(where_path, audio_directory_path);
    strcat(where_path, "/");

    strcat(where_path, "CHAPTER");
    memset(small_buffer,0,sizeof(small_buffer));
    itoa(chapter_num, small_buffer, 10);
    strcat(where_path, small_buffer);
    strcat(where_path, "_PAGE");
    memset(small_buffer,0,sizeof(small_buffer));
    itoa(page_num, small_buffer, 10);
    strcat(where_path, small_buffer);
    //strcat(where_path, ".TXT");
    strcat(where_path, ".MP3");

    /*f_opendir(&myDirectory, audio_directory_path); //open text directory
    memset(myFileinfo.fname,0,sizeof(myFileinfo.fname)); //clear myFileinfo.fname
    f_readdir(&myDirectory, &myFileinfo); //read file name of the first file in directory
    f_closedir(&myDirectory);
*/
    memset(small_buffer,0,sizeof(small_buffer));
}

void braille_translation(char* path) //the text data is to be translated to braille output
{

    strcpy(braille_contracted, "Contracted braille result"); //both contracted and uncontracted braille are saved

    strcpy(braille_uncontracted, "Uncontracted braille result");
}


//triggers the DAC to output audio and then outputs the eight six-bit binary signal to be displayed on the braille display
void display_data(void)
{
    if(flag1 == false && flag2 == false)
    {
        if(where_trigger == 0)
        {
            trigger_DAC = 1;
        }
        HAL_TIM_Base_Start_IT(&htim6); //Start TIM6 to tell DAC to output the audio data

        HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);
        HAL_Delay(250);
        HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);

        start_text_scrolling = 1;

        while(flag1 == false && flag2 == false) //while the navigation buttons are not pressed
        {
            if(HAL_GPIO_ReadPin(MODE_OUT_GPIO_Port, MODE_OUT_Pin) == GPIO_PIN_RESET)
            {
                memset(braille_output,0,sizeof(braille_output));
                strcpy(braille_output, braille_contracted);
                HAL_Delay(50);
            }
            else if(HAL_GPIO_ReadPin(MODE_OUT_GPIO_Port, MODE_OUT_Pin) == GPIO_PIN_SET)
            {
                memset(braille_output,0,sizeof(braille_output));
                strcpy(braille_output, braille_uncontracted);
                HAL_Delay(50);
            }

            if (t>=text_length) //scrolling of text
            {
                HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
                HAL_Delay(200);
                HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
                start_text_scrolling = 0;
                break;
            }
        }
        start_text_scrolling = 0;
    }
}




void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if(htim->Instance == TIM2)
  {
      if(HAL_GPIO_ReadPin(PLAY_OUT_GPIO_Port, PLAY_OUT_Pin) == GPIO_PIN_SET)
      {
          HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);
          if(start_text_scrolling == 1)
          {
              t++;
              HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_14);
          }

      }
      if(HAL_GPIO_ReadPin(PLAY_OUT_GPIO_Port, PLAY_OUT_Pin) == GPIO_PIN_RESET)
      {
          HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
      }
  }
  else if(htim->Instance == TIM6)
  {
      if(trigger_DAC == 1)
      {
          HAL_DAC_Start(&hdac, DAC_CHANNEL_2);
          HAL_DAC_SetValue(&hdac, DAC_CHANNEL_2, DAC_ALIGN_12B_R, text_audio_decoded[m]);
          //HAL_DAC_SetValue(&hdac, DAC_CHANNEL_2, DAC_ALIGN_12B_R, values1[m]);
          m++;
          if(m>=sizeof(values1)) //Once DAC finishes outputting all audio data, stop timer 6.
          {
              HAL_TIM_Base_Stop_IT(&htim6);
              m = 0;
              trigger_DAC = 0;
          }
      }
      else if(where_trigger == 1)
      {
          HAL_DAC_Start(&hdac, DAC_CHANNEL_2);
          HAL_DAC_SetValue(&hdac, DAC_CHANNEL_2, DAC_ALIGN_12B_R, where_audio_decoded[k]);
          //HAL_DAC_SetValue(&hdac, DAC_CHANNEL_2, DAC_ALIGN_12B_R, values2[k]);
          k++;
          if(k>=sizeof(values2)) //Once DAC finishes outputting all audio data, stop timer 6.
          {
              HAL_TIM_Base_Stop_IT(&htim6);
              k = 0;
              where_trigger = 0;
          }
      }
      /*HAL_DAC_Start(&hdac, DAC_CHANNEL_2);
      HAL_DAC_SetValue(&hdac, DAC_CHANNEL_2, DAC_ALIGN_12B_R, values[k]);
      k++;
      length = sizeof(values);
      if(k>=length) //Once DAC finishes outputting all audio data, stop timer 6.
      {
          HAL_TIM_Base_Stop_IT(&htim6);
          k = 0;
      }*/

  }

}






/*static void AudioCallback(void *context, int buffer)
{
    static int16_t audio_buffer0[4096];
    static int16_t audio_buffer1[4096];
    int offset, err;
    int outOfData = 0;
    int16_t *samples;


    if (buffer) {
        samples = audio_buffer0;
    } else {
        samples = audio_buffer1;
    }

    //MP3FindSyncWord finds the next byte-alinged sync word in the raw mp3 stream and returns value of offset to the
    //first sync word (bytes from start of buf). returns -1 if not found within byte range
    offset = MP3FindSyncWord((unsigned char*)read_ptr, bytes_left);
    bytes_left -= offset;
    read_ptr += offset;


    //MP3Decode decodes one frame of MP3 data from read_ptr and stores the decoded data as PCM data into samples, which contains the address of audio_buffer1.
    //Basically, MP3 Decode translates the read data from the file_read_buffer char array into PCM data and stores it into audio_buffer1.

    //Returns 0 if no error.
    //read_ptr contains the address of file_read_buffer char array, which is fixed array size of 8192.
    //HMP3Decoder  hMP3Decoder; A valid MP3 decoder instance pointer: hMP3Decoder = MP3InitDecoder();
    //samples contains the address of audio_buffer1, is of int16_t type and fixed array size of 4096.

    err = MP3Decode(hMP3Decoder, (unsigned char**)&read_ptr, (int*)&bytes_left, samples, 0);

    if (err) {
         error occurred or file_read_buffer is out of data.
        switch (err) {
        case ERR_MP3_INDATA_UNDERFLOW:
            outOfData = 1;
            break;
        case ERR_MP3_MAINDATA_UNDERFLOW:
             do nothing - next call to decode will provide more mainData
            break;
        case ERR_MP3_FREE_BITRATE_SYNC:
        default:
            outOfData = 1;
            break;
        }
    } else {
        // if no error, then get info about last MP3 frame decoded in terms of:
        // number of samples decoded, sample rate, bitrate, etc.
        // Output info is stored in address of mp3FrameInfo of MP3FrameInfo struct.

        MP3GetLastFrameInfo(hMP3Decoder, &mp3FrameInfo);

        // Duplicate data in case of mono to maintain playback speed
        if (mp3FrameInfo.nChans == 1) {
            for(int i = mp3FrameInfo.outputSamps;i >= 0;i--)    {
                samples[2 * i]=samples[i];
                samples[2 * i + 1]=samples[i];
            }
            mp3FrameInfo.outputSamps *= 2;
        }
    }

    if (!outOfData) {
        ProvideAudioBuffer(samples, mp3FrameInfo.outputSamps);
    }
}





static uint32_t Mp3ReadId3V2Text(FIL* pInFile, uint32_t unDataLen, char* pszBuffer, uint32_t unBufferSize)
{
    UINT unRead = 0;
    BYTE byEncoding = 0;
    if((f_read(pInFile, &byEncoding, 1, &unRead) == FR_OK) && (unRead == 1))
    {
        unDataLen--;
        if(unDataLen <= (unBufferSize - 1))
        {
            if((f_read(pInFile, pszBuffer, unDataLen, &unRead) == FR_OK) ||
                    (unRead == unDataLen))
            {
                if(byEncoding == 0)
                {
                    // ISO-8859-1 multibyte
                    // just add a terminating zero
                    pszBuffer[unDataLen] = 0;
                }
                else if(byEncoding == 1)
                {
                    // UTF16LE unicode
                    uint32_t r = 0;
                    uint32_t w = 0;
                    if((unDataLen > 2) && (pszBuffer[0] == 0xFF) && (pszBuffer[1] == 0xFE))
                    {
                        // ignore BOM, assume LE
                        r = 2;
                    }
                    for(; r < unDataLen; r += 2, w += 1)
                    {
                        // should be acceptable for 7 bit ascii
                        pszBuffer[w] = pszBuffer[r];
                    }
                    pszBuffer[w] = 0;
                }
            }
            else
            {
                return 1;
            }
        }
        else
        {
            // we won't read a partial text
            if(f_lseek(pInFile, f_tell(pInFile) + unDataLen) != FR_OK)
            {
                return 1;
            }
        }
    }
    else
    {
        return 1;
    }
    return 0;
}


 * Taken from
 * http://www.mikrocontroller.net/topic/252319

static uint32_t Mp3ReadId3V2Tag(FIL* pInFile, char* pszArtist, uint32_t unArtistSize, char* pszTitle, uint32_t unTitleSize)
{
    pszArtist[0] = 0;
    pszTitle[0] = 0;

    BYTE id3hd[10];
    UINT unRead = 0;
    if((f_read(pInFile, id3hd, 10, &unRead) != FR_OK) || (unRead != 10))
    {
        return 1;
    }
    else
    {
        uint32_t unSkip = 0;
        if((unRead == 10) &&
                (id3hd[0] == 'I') &&
                (id3hd[1] == 'D') &&
                (id3hd[2] == '3'))
        {
            unSkip += 10;
            unSkip = ((id3hd[6] & 0x7f) << 21) | ((id3hd[7] & 0x7f) << 14) | ((id3hd[8] & 0x7f) << 7) | (id3hd[9] & 0x7f);

            // try to get some information from the tag
            // skip the extended header, if present
            uint8_t unVersion = id3hd[3];
            if(id3hd[5] & 0x40)
            {
                BYTE exhd[4];
                f_read(pInFile, exhd, 4, &unRead);
                size_t unExHdrSkip = ((exhd[0] & 0x7f) << 21) | ((exhd[1] & 0x7f) << 14) | ((exhd[2] & 0x7f) << 7) | (exhd[3] & 0x7f);
                unExHdrSkip -= 4;
                if(f_lseek(pInFile, f_tell(pInFile) + unExHdrSkip) != FR_OK)
                {
                    return 1;
                }
            }
            uint32_t nFramesToRead = 2;
            while(nFramesToRead > 0)
            {
                char frhd[10];
                if((f_read(pInFile, frhd, 10, &unRead) != FR_OK) || (unRead != 10))
                {
                    return 1;
                }
                if((frhd[0] == 0) || (strncmp(frhd, "3DI", 3) == 0))
                {
                    break;
                }
                char szFrameId[5] = {0, 0, 0, 0, 0};
                memcpy(szFrameId, frhd, 4);
                uint32_t unFrameSize = 0;
                uint32_t i = 0;
                for(; i < 4; i++)
                {
                    if(unVersion == 3)
                    {
                        // ID3v2.3
                        unFrameSize <<= 8;
                        unFrameSize += frhd[i + 4];
                    }
                    if(unVersion == 4)
                    {
                        // ID3v2.4
                        unFrameSize <<= 7;
                        unFrameSize += frhd[i + 4] & 0x7F;
                    }
                }

                if(strcmp(szFrameId, "TPE1") == 0)
                {
                    // artist
                    if(Mp3ReadId3V2Text(pInFile, unFrameSize, pszArtist, unArtistSize) != 0)
                    {
                        break;
                    }
                    nFramesToRead--;
                }
                else if(strcmp(szFrameId, "TIT2") == 0)
                {
                    // title
                    if(Mp3ReadId3V2Text(pInFile, unFrameSize, pszTitle, unTitleSize) != 0)
                    {
                        break;
                    }
                    nFramesToRead--;
                }
                else
                {
                    if(f_lseek(pInFile, f_tell(pInFile) + unFrameSize) != FR_OK)
                    {
                        return 1;
                    }
                }
            }
        }
        if(f_lseek(pInFile, unSkip) != FR_OK)
        {
            return 1;
        }
    }

    return 0;
}*/







/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
